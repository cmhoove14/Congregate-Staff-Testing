---
title: "Optimizing COVID-19 screening for shift-workers to reduce introduction of disease from the community"
subtitle: "Methods and results"
author: "Chris Hoover et al"
date: "5/20/2021"
output: word_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo    = FALSE,
                      include = FALSE,
                      warning = FALSE,
                      message = FALSE)

library(tidyverse)
library(patchwork)
source(here::here("R/Utils.R"))
source(here::here("R/Sim_Functions.R"))

```
# Methods  
## Model framework and parameterization for SARS-CoV2  
Building on previous work investigating the effects of non-pharmaceutical interventions [CITE](https://doi.org/10.1073/pnas.1616438114) and testing [CITE](https://doi.org/10.1126/sciadv.abd5393) on the transmission of infectious diseases, individual contributions to SARS-CoV2 transmission through time were modeled from an infectiousness profile, $\beta_t$, generated from key biological parameters of the virus that determine the distribution of infectiousness over time. We used the probability density function of the triangle distribution to model $\beta_t$, with infectiousness beginning after the latent period ($t_{latent}$), ending after the duration of the infectious period ($t_{infectious}$), and peaking at some point in between ($t_{peak}$) ($a=t_{latent}$, $b=t_{tot}=t_{infectious}+t_{latent}$, $c=t_{peak}$, and a<c<b ; Fig 1a). 

The viral dynamics of SARS-CoV2 make control efforts challenging, as high infectiousness in the absence of symptoms is common [CITE](https://wwwnc.cdc.gov/eid/article/27/4/20-4576_article), [CITE](https://science.sciencemag.org/content/368/6490/489). In terms of the infectiousness profile for SARS-CoV2, this means that peak infectiousness ($t_{peak}$) tends to coincide with the onset of symptoms (for cases that are symptomatic), but occurs after completion of the latent period (i.e. $t_{peak}\approx t_{incubation}$ and $t_{incubation}>t_{latent}$). The expected number of new cases generated by an individual at time $t$ is thus $r_{t}=\mathcal{R}\beta_{t}$, where $\mathcal{R}$ is the effective reproduction number interpreted as the expected number of cases generated by a new case over the duration of their infectious period. The model therefore assumes that new cases are most likely to be generated around the time of peak infectiousness, $t_{peak}$. Table 1 lists the distributions of $t_{incubation}$, $t_{latent}$, and $t_{infectious}$ used here.

In the presence of interventions that isolate infectious individuals prior to $t_{tot}$, e.g. through contact tracing, self-isolation following the onset of symptoms, or testing, the effect of isolation on $\mathcal{R}$ can be directly estimated from the time to isolation as $\mathcal{R}_{iso}=\mathcal{R}\big(1-\int_{t_{iso}}^{t_{tot}}\beta_tdt\big)$, where $t_{iso}$ is the time at which isolation occurs. Reducing $\mathcal{R}_{iso}$ via improved contact tracing or more frequent testing can thus be envisioned as removing a larger slice from the overall infectiousness triangle by reducing $t_{iso}$ (Fig 1a). The size of the slice removed can be estimated from the probability density function of the triangle distribution and the parameters $t_{latent}$, $t_{incubation}$, $t_{tot}$, and $t_{iso}$.  

Figure 1b shows the relationship between $\mathcal{R}_{iso}$ and $t_{iso}$ is sigmoidal, implying earlier isolation is incrementally more effective and the benefits of isolation level off later in the infectious period. Other interventions that reduce $\mathcal{R}$ across all levels of infectiousness such as wearing a mask or reducing the contact rate between infectious and susceptible individuals can also be accommodated simply by multiplying $\mathcal{R}$ by a constant.

```{r include = FALSE, eval = FALSE}
# Text to add re: if t_iso is less than t_peak: more complicated integral

, whereas if $t_{iso}<t_{peak}$, reduction in $R$ is: $\frac{2(t_{tot}-t_{iso})}{t_{infectious}(t_{tot}-t_{peak})}+\frac{2}{t_{infectious}}+\frac{2(t_{iso})}{t_{infectious}(t_{peak}-t_{latent})}$
```


```{r tri_examp, echo = FALSE}
# Triangle schematic -----------------
base_R   <- 1
t_peak   <- 5
t_latent <- t_peak - 1
t_infect <- 9
t_tot    <- t_latent + t_infect
dt       <- 1

tri <- c(infectious_profile(t_latent, t_peak, t_infect, dt),
         #Buffer with 0 at the end for plot aesthetic
         rep(0, length(seq(0, 14, by = dt))-length(seq(0, t_tot, by = dt))))

tri_R <- tri*base_R

t_iso <- t_peak + 2

d_iso <- dtriangle(x = t_iso, 
                   a = t_latent,
                   b = t_tot,
                   c = t_peak)*dt

# Plot with infectiousness removed
tri_examp_plot <- tibble(
  d_inf = seq(0, 14, by = dt),
  Rt    = tri_R
  ) %>% 
  ggplot() +
  geom_line(aes(x = d_inf, y = Rt)) + 
  geom_polygon(
    data    = tibble(x = c(t_iso, t_iso,        t_tot),
                     y = c(0    , d_iso*base_R, 0)),
    mapping = aes(x = x, y = y),
    fill    = "grey50",
    col     = "red"
    ) +
  scale_x_continuous(breaks = seq(0,14,2), 
                     limits = c(0,14)) +
  theme_classic() +
  theme(axis.text = element_text(size = 11),
        axis.title.y = element_text(size = 15),
        axis.title.x = element_text(size = 13)) +
  labs(x   = "Days since infection",
       y   = expression(italic(r[t])),
       tag = "A")

# R_iso as function of t_iso -----------------
t_isos <- seq(0,14,0.01)

base_R_iso <- R_iso(t_latent, t_peak, t_infect, t_iso, base_R, 0.01)

r_iso_t_iso_plot <- tibble(
  t_isos = t_isos,
  R_isos = sapply(t_isos, function(t){
    R_iso(t_latent, t_peak, t_infect, t, base_R,0.01)
  })
) %>% 
  ggplot() +
    geom_line(aes(x = t_isos, y = R_isos)) +
    geom_point(data = tibble(x = t_iso, y = base_R_iso),
               aes(x = x, y = y),
               col = "red", size = 2) +
    theme_classic() +
    theme(axis.text = element_text(size = 11),
          axis.title = element_text(size = 13)) +
    scale_x_continuous(breaks = seq(0,14,by=2)) +
    labs(x = expression(t[iso]),
         y = expression(R[iso]),
         tag = "B")
```

```{r save_triangle, eval = FALSE, include = FALSE, echo = FALSE}
tri_examp_plot

ggsave(here::here("Plots/triangle_example.png"),
       width = 6, height = 3, units = "in")

tri_examp_plot2 <- tibble(
  d_inf = seq(0, t_tot, by = dt),
  Rt    = tri_R
  ) %>% 
  ggplot() +
  geom_line(aes(x = d_inf, y = Rt)) + 
  scale_x_continuous(breaks = seq(0,14,2)) +
  theme_classic() +
  theme(axis.text = element_text(size = 11),
        axis.title = element_text(size = 13)) +
  labs(x   = "Days since infection",
       y   = expression(beta[t]),
       tag = "A")

ggsave(here::here("Plots/triangle_example_no_iso.png"),
       width = 6, height = 3, units = "in")

```

```{r p_tiso, echo = FALSE, fig.width=6, fig.height=4, fig.cap="Probability of going $t$ days without being tested given constant testing frequencies"}
test_freqs <- c(7,2,1,0.5)/7

fd_grid <- as.data.frame(expand.grid("freqs" = test_freqs, 
                                     "days"  = c(0:14),
                                     "delay" = c(0:2)))

fd_grid$p_t_iso = apply(fd_grid,1,function(x){
  1-(1-x[1])^(x[2]-x[3])
})

fd_grid$p_t_iso[which(fd_grid$days <= fd_grid$delay)] <- 0

d_labs <- paste0("d = ", c(0:2))
names(d_labs) <- c(0:2)

p_iso_t_freq_plot <- fd_grid %>% 
  ggplot(aes(x = days, y = p_t_iso, col = as.factor(freqs))) +
    geom_line(size = 1) +
    facet_wrap("delay", nrow = 3,
               labeller = labeller(delay = d_labs)) +
    theme_classic() +
    theme(axis.text = element_text(size = 11),
          axis.title = element_text(size = 13),
          strip.background = element_blank(),
          strip.text = element_text(face = "italic",
                                    size = 11)) +
    scale_color_manual(values = RColorBrewer::brewer.pal(7, "Purples")[7:4],
                       breaks = test_freqs,
                       labels = c("7 (daily)", "2 (twice \nweekly)", "1 (weekly)", "0.5 (biweekly)")) +
    scale_x_continuous(breaks = seq(0,14,2)) +
    ylim(c(0,1)) +
    labs(x = expression(tau~days),
         y = expression(P(t[iso]<=tau)),
         col = "Tests per\n Week (f)",
         tag = "D")
```

```{r test_freq_r_red_par_uncertainty_distn, echo = FALSE}
n_sims <- 100
R_iso_test_freqs <- bind_rows(lapply(test_freqs, function(f){
  # Draw from distributions for key time periods
  inf_pars <- sim_inf_pars(n_sims)
  
  t_inc_samps <- inf_pars[,1]
  t_lnt_samps <- inf_pars[,2]
  t_inf_samps <- inf_pars[,3]
  
  R_iso_d0 <- sapply(1:n_sims, function(i){
    R_iso_f(
      t_latent     = t_lnt_samps[i], 
      t_peak       = t_inc_samps[i], 
      t_infectious = t_inf_samps[i], 
      t_freq       = f, 
      dt           = 0.1, 
      d            = 0,
      R            = base_R
    )
  })
  
  R_iso_d1 <- sapply(1:n_sims, function(i){
    R_iso_f(
      t_latent     = t_lnt_samps[i], 
      t_peak       = t_inc_samps[i], 
      t_infectious = t_inf_samps[i], 
      t_freq       = f, 
      dt           = 0.1, 
      d            = 1,
      R            = base_R
    )
  })

  R_iso_d2 <- sapply(1:n_sims, function(i){
    R_iso_f(
      t_latent     = t_lnt_samps[i], 
      t_peak       = t_inc_samps[i], 
      t_infectious = t_inf_samps[i], 
      t_freq       = f, 
      dt           = 0.1, 
      d            = 2,
      R            = base_R
    )
  })
    
  return(tibble(R_isos = c(R_iso_d0, R_iso_d1, R_iso_d2),
                delay  = c(rep(0, n_sims), rep(1, n_sims), rep(2, n_sims)),
                t_freq = f))
}))

exp_R_iso_t_freq_plot <- R_iso_test_freqs %>% 
  ggplot(aes(y = R_isos, x = as.factor(t_freq), col = as.factor(delay))) +
    geom_boxplot() +
    scale_x_discrete(labels = rev(test_freqs*7)) +
    scale_color_manual(values = RColorBrewer::brewer.pal(7, "PuRd")[c(4,5,7)]) +
    ylim(c(0, base_R)) +
    theme_classic() +
    theme(axis.text = element_text(size = 11),
          axis.title = element_text(size = 13)) +
    labs(x = "Tests per Week (f)",
         y = expression(R[iso]),
         col = expression(italic(d)),
         tag = "C")
```


```{r test_freq_r_red, eval = FALSE}
R_iso_d0s <- sapply(test_freqs, function(f){
    R_iso_f(
      t_latent     = t_latent, 
      t_peak       = t_peak, 
      t_infectious = t_infect, 
      t_freq       = f, 
      dt           = dt, 
      d            = 0,
      R            = base_R
    )
  })

R_iso_d1s <- sapply(test_freqs, function(f){
    R_iso_f(
      t_latent     = t_latent, 
      t_peak       = t_peak, 
      t_infectious = t_infect, 
      t_freq       = f, 
      dt           = dt, 
      d            = 1,
      R            = base_R
    )
  })

R_iso_d2s <- sapply(test_freqs, function(f){
    R_iso_f(
      t_latent     = t_latent, 
      t_peak       = t_peak, 
      t_infectious = t_infect, 
      t_freq       = f, 
      dt           = dt, 
      d            = 2,
      R            = base_R
    )
  })

R_iso_test_freqs2 <- tibble(R_isos = c(R_iso_d0s, R_iso_d1s, R_iso_d2s),
                           delay  = c(rep(0, length(test_freqs)), 
                                      rep(1, length(test_freqs)), 
                                      rep(2, length(test_freqs))),
                           t_freq = rep(test_freqs, times = 3))

exp_R_iso_t_freq_plot2 <- R_iso_test_freqs2 %>% 
  ggplot(aes(y = R_isos, x = as.factor(t_freq), col = as.factor(delay))) +
    geom_violin(alpha = 0.7) +
    #geom_point(alpha = 0.5, size = 0.3, position = position_dodge2(0.5)) +
    stat_summary(fun = "median", #fun.min = "q_25", fun.max = "q_75",
                 position = position_dodge2(1),
                 size = 0.2) +
    scale_x_discrete(labels = rev(1/test_freqs)) +
    ylim(c(0, base_R)) +
    theme_classic() +
    theme(axis.text = element_text(size = 11),
        axis.title = element_text(size = 13)) +
    labs(x = "Testing frequency (days)",
         y = expression(R[iso]),
         col = expression(italic(d)),
         tag = "C")
```

**Table 1**: Distributions and parameter values used in analytic framework and model simulations. The incubation period is defined as the time between infection and onset of infectiousness, the latent period the time between infection and symptoms, and the infectious period the total time a case is infectious.  
```{r tab1, include = TRUE}
data.frame("Parameter" = c("Incubation Period", "Latent Period", "Infectious Period"),
           "Distribution" = c("Lognormal(1.63, 0.5)", "t_inc - Uniform(0,2)", "Uniform(7,10)"),
           "Source" = rep("CITE", 3)) %>% 
  knitr::kable()
```

We define the test frequency, $f$, as the average number of tests per week. Assuming testing is done randomly through time and is independent of symptoms or known contacts, the probability of being infectious and going $t$ days without being tested and isolated can be estimated as $(1-f/7)^t$, where, for example $f=1$ if testing is conducted weekly. The probability that isolation has occurred by day $\tau$ can then be estimated as $\mathrm{P}(t_{iso}\leq\tau)=1-(1-f/7)^\tau$, assuming isolation occurs immediately after testing. Given substantial turnaround times between testing and isolation, particularly when relying on PCR-based tests, the delay, $d$, between testing and isolation can also be incorporated as: $\mathrm{P}(t_{iso}=\tau)=1-(1-f/7)^{\tau-d}$. Figure 1d shows that such delays have a detrimental effect on the probability of achieving prompt isolation, particularly by making isolation prior to the delay ($t_{iso}<d$) impossible. 

Testing frequency and delay can also be incorporated into estimation of $\mathcal{R}_{iso}$, with the reduction in $\mathcal{R}_{iso}$ due to isolation estimated from infectiousness on day $\tau$ weighted by the probability of being isolated on day $\tau$. Discretizing, this gives: $$\mathcal{R}_{iso}=\mathcal{R}-\sum_{\tau=t_{latent}+d}^{t_{tot}}r_\tau\bigg(1-\Big(1-\frac{f}{7}\Big)^{\tau-t_{latent}-d}\bigg)$$

Figure 1c shows distributions of $R_{iso}$ derived from 100 random draws sampling from uncertainty in the SARS-CoV2 latent, peak, and total infectious periods, across test frequencies ranging from daily ($f=7$) to biweekly ($f=0.5$) and test delays from 0 to 2 days. These results again reiterate the importance of reducing test delays, as $\mathcal{R}_{iso}$ is similar when testing every day ($f=7$) with a two-day turnaround time for test results ($d=2$) vs testing twice per week ($f=2$) with immediate test results ($d=0$) (fig 1c, median $\mathcal{R}_{iso}(d=0,f=2)=$ `r round(median(R_iso_test_freqs$R_isos[which(R_iso_test_freqs$delay == 0 & R_iso_test_freqs$t_freq == test_freqs[2])]), digits = 2)` and $\mathcal{R}_{iso}(d=2,f=7)=$ `r round(median(R_iso_test_freqs$R_isos[which(R_iso_test_freqs$delay == 2 & R_iso_test_freqs$t_freq == test_freqs[1])]), digits = 2)`, respectively).

```{r mod_schematic_plot, echo = FALSE, include = TRUE, fig.width=8, fig.height=6, fig.cap="**Figure 1. Analytic framework exploring effects of variable infectiousness through time, testing frequencies, and delays on SARS-CoV-2 transmission.**"}

# Four panels with patchwork
(tri_examp_plot / r_iso_t_iso_plot / exp_R_iso_t_freq_plot) | p_iso_t_freq_plot 

ggsave(here::here("Plots/Framework_Analysis.png"),
       units = "in", height = 6, width = 7)

ggsave(here::here("Plots/submit/Figure1.jpg"),
       units = "in", height = 6, width = 6.5, dpi = 600)

```

*[Fig 1 caption continued]*  
A) Example infectiousness profile for $\mathcal{R}=1$, $t_{latent}=$ `r t_latent`, $t_{incubation}=$ `r t_peak`, $t_{infectious}=$ `r t_infect`, with line indicating infectiousness ($r_t$) through time and shaded area demonstrating infectiousness slice removed if isolation occurs at two days after symptom onset, $t_{iso}=$ `r t_iso`, leading to $\mathcal{R}_{iso}=$ `r round(base_R_iso, 2)`. B) $\mathcal{R}_{iso}$ as a function of $t_{iso}$ with same parameters as in A and point indicating scenario depicted in A. C)  Boxplots showing distributions of $\mathcal{R}_{iso}$ as a function of testing frequency, $f$, and test delay, $d$, incorporating uncertainty in $t_{latent}$, $t_{incubation}$, and $t_{infectious}$ by drawing $n=100$ parameter sets for each, with baseline $\mathcal{R}=1$. Boxplots indicate median and interquartile range. D) Relationship between testing frequency, $f$, test delay, $d$, and probability isolation occurs by day $t$, i.e. $t_{iso}\leq \tau$, demonstrating that delays in testing substantially reduce the probability of prompt isolation, particularly in more frequent testing scenarios.  

## Individual-based model simulations   

### Model setup   
We next describe the development and simulation of an individual based model to incorporate staff schedules and expand the modeling framework above to a facility-level setting. In a modeled facility, $n$ staff are assigned a work schedule that determines time frames when they are in the facility interacting with residents and other staff working at the same time. We denote $\mathcal{W}(w_{it})$ as an indicator function for whether staff member $i$ is working at the facility on day $t$. In addition to their work schedule, all staff are assigned a testing schedule, encoded by function $\mathcal{T}(w_{it})$, with different testing schedules discussed further below. The model is simulated at an 8-hour time step, with each time step corresponding to a work shift also described further below.  

Staff move through susceptible (S), exposed (E), infected (I), and recovered (R) states, with the infected state corresponding to time when $\beta_{it}>0$. Parameters for newly exposed staff are drawn to determine $t_{latent}$, $t_{incubation}$, and $t_{infectious}$, from which an infectiousness profile, $\beta_{it}$ is generated. Tested staff produce a positive result if $\beta_{it}>0$ and $\mathcal{T}(w_{it})=1$, at which time they enter a quarantined (Q) state immediately if $d=0$, or first enter a tested (T) state before Q if there is a delay between test administration and the test result. Staff in state Q have $\mathcal{W}(w_{it})=0$ for 10 days and have $\mathcal{T}(w_{it})=0$ for 90 days following a positive result.

Assuming constant $\mathcal{R}$ across all individuals, the expected number of cases produced in the facility on day $t$ by individual $i$ is $r_{it}=\mathcal{R}\beta_{it}\mathcal{W}(w_{it})$. Staff may acquire infection from the community according to the community prevalence when they are not working ($\mathcal{W}(w_{it})=0$) or from fellow staff when working ($\mathcal{W}(w_{it})=1$), where the force of infection is $\lambda^{work}_{it}=\frac{\sum_{i=1}^nr_{it}}{n}$. The main outcome for the model simulations is the number of infections in the facility generated by staff, estimated as: $\mathcal{I}^{tot}_{sim}=\sum_{t=1}^{t_{sim}}\sum_{i=1}^n\mathcal{W}(w_{it})r_{it}$.  

### Staffing and testing strategies  
CDCR collects extensive operations records including information on custody workdays (e.g., Mon-Thurs), work shifts (e.g., morning, evening, night), and SARS-CoV2 testing schedules. We use this information to generate a realistic representation of staff working schedules in model simulations by sampling from work schedules commonly observed among CDCR custody staff.   

Two experimental testing strategies were considered in model simulations. Under a random testing strategy, testing for each worker occurs at random during their work shifts depending on the frequency (i.e. with $f=2$, workers would be tested during two of their shifts, chosen at random each week). Under a systematic testing strategy, each worker is always tested on the same day(s) of their shift each week. For $f=1$, systematic testing always occurs on the first day of their work week; for $f=2$, systematic testing always occurs on the first and third days; and for $f=4$, testing occurs on each of the first four work days in a week. 

We assume all tests conducted when $\beta_{it}>0$ return a positive result. The total number of tests conducted in each simulation is recorded as: $\mathcal{T}^{tot}_{sim}=\sum_{t=1}^{t_{sim}}\sum_{i=1}^n\mathcal{T}(w_{it})$. Combined with the expected number of cases in the simulation, we estimate the incremental test effectiveness ratio (ITER) as: $\mathrm{ITER}=\frac{\mathcal{T}^{tot}_{sim}}{\mathcal{I}^{tot}_{sim}-\mathcal{I}^{tot}_{ref}}$, where $\mathcal{I}^{tot}_{ref}$ is the number of infections in a reference scenario with no testing. The ITER can be interpreted as the number of tests needed to prevent one infection in the simulation scenario being evaluated.   

All simulations, analyses, and visualizations were compiled in R software version 4.0.4 CITE with aid from the tidyverse CITE, triangle CITE, and patchwork CITE packages. Code is made available freely online at https://github.com/cmhoove14/CDCR-Staff-Testing.  

# Results  
## CDCR Staff Working and Testing schedules  
Four typical staff workweek schedules were identified using K-means clustering. Most common was a four-day workweek in which the staff member worked four consecutive days (e.g., Monday-Thursday), though the first day of the workweek varied across staff (Figure 2). Work shifts also tended to show consistent patterns. Staff typically worked either the morning, evening, or night shift, though alternating between morning and evening shifts was also common. Generation of work schedules in simulations was informed by these observed CDCR schedules by sampling one of the consecutive 4-day sequences of work days shown in figure 2 and a regular shift (morning, evening, night) for each worker. A fifth shift was then added to each worker’s weekly schedule by randomly sampling from all other potential shifts.   
Tests were most often administered on Tuesdays (if the staff had Tuesday in their typical workweek) regardless of whether it was the first day of the staff’s workweek. Testing on Wednesday and Thursday was also common across work schedules. Only 10% of tests were conducted on the first day of a consecutive work period of 4 or more days, implying testing was rarely conducted in a systematic manner in relation to structured work schedules. Test results were usually returned on the same day or were delayed by one day from specimen collection, and almost all test results were received within 2 days of specimen collection.  

[Figure 2]  

```{r staff_numbers}
n_staff_MR <- 5969
n_staff_RU <- 6180
n_staff_TS <- 9243
n_staff_ST <- 6936

n_staff_tot <- n_staff_MR + n_staff_RU + n_staff_TS + n_staff_ST

per_MR <- round(n_staff_MR/n_staff_tot, 2)
per_RU <- round(n_staff_RU/n_staff_tot, 2)
per_TS <- round(n_staff_TS/n_staff_tot, 2)
per_ST <- round(n_staff_ST/n_staff_tot, 2)
```


**Figure 2. Staff working and testing schedules.** Four typical weekly work schedules (y-axis) were identified among CDCR custody staff. These include a Monday to Thursday workweek (`r per_MR*100`% staff), a Thursday to Sunday workweek (`r per_RU*100`% staff), a Tuesday to Saturday workweek (`r per_TS*100`% staff), and a Saturday to Tuesday workweek (`r per_ST*100`% staff). The red shading shows the mean proportion of staff workdays that consist of a particular day of the week (x-axis; i.e. darker shades of red indicate that staff with the specified schedule very commonly work on that day). The size of the black circles represents the mean proportion of the total number of tests administered to each group that were given on the specified day.

## Simulation Results  
```{r load_sim_results}
load(here::here("data/sim_results_processed.RData"))

```

Systematic testing strategies were found to consistently outperform random testing strategies in terms of preventing infections within simulated facilities. Figure 3 shows a comparison of the number of infections generated ($\mathcal{I}^{tot}_{sim}$) when implementing random vs systematic testing strategies across testing frequencies, levels of community prevalence, and within-facility $\mathcal{R}$ with either no delay or a one day delay between test administration and isolation of infectious workers. In the highest transmission scenario ($CP=1\%, \mathcal{R}=1.5$), no testing led to a median $\mathcal{I}^{tot}_{sim}=$ `r round(sims_sum2 %>% filter(testfreq == 0, work_sched == "leaky", delay == 0, R == 1.5, lambda == lambda3) %>% pull(totcases_1), 2)` (IQR `r round(sims_sum2 %>% filter(testfreq == 0, work_sched == "leaky", delay == 0, R == 1.5, lambda == lambda3) %>% pull(totcases_2), 2)` - `r round(sims_sum2 %>% filter(testfreq == 0, work_sched == "leaky", delay == 0, R == 1.5, lambda == lambda3) %>% pull(totcases_3), 2)`). Testing randomly once per week with no delay to isolation resulted in a median $\mathcal{I}^{tot}_{sim}=$ `r round(sims_sum2 %>% filter(testfreq == 1, work_sched == "leaky", delay == 0, R == 1.5, lambda == lambda3, testsys == "random") %>% pull(totcases_1), 2)` (IQR `r round(sims_sum2 %>% filter(testfreq == 1, work_sched == "leaky", delay == 0, R == 1.5, lambda == lambda3, testsys == "random") %>% pull(totcases_2), 2)` - `r round(sims_sum2 %>% filter(testfreq == 1, work_sched == "leaky", delay == 0, R == 1.5, lambda == lambda3, testsys == "random") %>% pull(totcases_3), 2)`; Fig 3 right panel, rightmost yellow circle), whereas testing systematically on the first day of the work week resulted in $\mathcal{I}^{tot}_{sim}=$ `r round(sims_sum2 %>% filter(testfreq == 1, work_sched == "leaky", delay == 0, R == 1.5, lambda == lambda3, testsys == "systematic") %>% pull(totcases_1), 2)` (IQR `r round(sims_sum2 %>% filter(testfreq == 1, work_sched == "leaky", delay == 0, R == 1.5, lambda == lambda3, testsys == "systematic") %>% pull(totcases_2), 2)` - `r round(sims_sum2 %>% filter(testfreq == 1, work_sched == "leaky", delay == 0, R == 1.5, lambda == lambda3, testsys == "systematic") %>% pull(totcases_3), 2)`; Fig 3 right panel, rightmost yellow square). However, systematic testing that is accompanied by a one day delay leads to $\mathcal{I}^{tot}_{sim}=$ `r round(sims_sum2 %>% filter(testfreq == 1, work_sched == "leaky", delay == 1, R == 1.5, lambda == lambda3, testsys == "systematic") %>% pull(totcases_1), 2)` (IQR `r round(sims_sum2 %>% filter(testfreq == 1, work_sched == "leaky", delay == 1, R == 1.5, lambda == lambda3, testsys == "systematic") %>% pull(totcases_2), 2)` - `r round(sims_sum2 %>% filter(testfreq == 1, work_sched == "leaky", delay == 1, R == 1.5, lambda == lambda3, testsys == "systematic") %>% pull(totcases_3), 2)`; Fig 3 right panel, rightmost yellow cross). Across all transmission scenarios, biweekly systematic testing with no delay to isolation averted an average of `r round(mean(sims_sum2 %>% filter(testfreq == 0.5, work_sched == "leaky", delay == 0, testsys == "systematic") %>% pull(peravoided_1)), 2)*100`% of transmissions that would have occurred with no testing, while random testing averted an average of `r round(mean(sims_sum2 %>% filter(testfreq == 0.5, work_sched == "leaky", delay == 0, testsys == "random") %>% pull(peravoided_1)), 2)*100`% of transmissions. For weekly frequency, systematic testing averted an average of `r round(mean(sims_sum2 %>% filter(testfreq == 1, work_sched == "leaky", delay == 0, testsys == "systematic") %>% pull(peravoided_1)), 2)*100`% of transmissions versus `r round(mean(sims_sum2 %>% filter(testfreq == 1, work_sched == "leaky", delay == 0, testsys == "random") %>% pull(peravoided_1)), 2)*100`% of transmissions when testing randomly; and for twice weekly testing, systematic testing averted and average of `r round(mean(sims_sum2 %>% filter(testfreq == 2, work_sched == "leaky", delay == 0, testsys == "systematic") %>% pull(peravoided_1)), 2)*100`% of transmissions versus `r round(mean(sims_sum2 %>% filter(testfreq == 2, work_sched == "leaky", delay == 0, testsys == "random") %>% pull(peravoided_1)), 2)*100`% of transmissions when testing randomly.

The horizontal gray line in figure 3 demonstrates a potential threshold number of infections to avoid exceeding at $\mathcal{I}^{tot}_{sim}=18$. This threshold corresponds to an average of 1 transmission event within the simulated facility every ten days. Implementing a systematic--rather than random--testing strategy can be sufficient to prevent $\mathcal{I}^{tot}_{sim}$ from exceeding such a threshold without changing the frequency in many transmission scenarios (e.g. compare circles to squares and of the same color inf figure 3) though in the highest transmission scenarios, greater than twice-weekly testing may be needed. Table 2 additionally shows the testing frequency in tests per week under a systematic testing strategy necessary to ensure that the upper quartile of expected transmission events is maintained below this threshold.

```{r sim_results, include = TRUE, fig.width=7, fig.height=5, fig.cap="**Figure 3. Number of expected infections generated in a facility from model simulations comparing random and systematic testing strategies across transmission scenarios, test frequencies, and test delays**. Systematic testing strategies ([squares], [crosses]) prevent more infections than random strategies ([circles], [triangles]) across all transmission scenarios and test frequencies. More infections are expected in transmission scenarios with higher within facility $\\mathcal{R}$ and higher community prevalence. Preventing test delays (squares compared to crosses and triangles compared to circles) and increasing test frequency (red=lowest frequency, blue=highest frequency) also reduces the number of infections. The horizontal gray line serves as a reference to assess the testing frequency needed to maintain $\\mathcal{I}^{tot}_{sim}\\leq18$ (corresponding to one transmission event every ten days) across different transmission scenarios. Error bars represent the interquartile range of $\\mathcal{I}^{tot}_{sim}$ derived from 100 simulations per scenario."}
thresh  <-  days/10

sims_sum_ggplot %>% 
  #filter(measure %in% c("Transmissions avoided/\n1000 tests", "Transmissions"), work_sched == "leaky") %>% 
  filter(measure == "Transmissions", work_sched == "leaky", delay %in% c(0,1), `Test Frequency` != 0) %>% 
  mutate(`Test Frequency` = factor(case_when(`Test Frequency` == 0.5 ~ "0.5 (biweekly)",
                                             `Test Frequency` == 1 ~ "1 (weekly)",
                                             `Test Frequency` == 2 ~ "2 (twice weekly)",
                                             `Test Frequency` == 4 ~ "4 (every shift)"),
         levels = c("0.5 (biweekly)", "1 (weekly)", "2 (twice weekly)", "4 (every shift)"))) %>% 
  ggplot(aes(x = `Community Prevalence`,
             y = Med,
             ymin = q25,
             ymax = q75,
             shape = `Test Strategy Delay`,
             col = `Test Frequency`)) +
    geom_hline(yintercept = thresh, col = "grey50", alpha = 0.5) +
    geom_point(position = position_dodge(0.7)) +
    geom_errorbar(width = 0.1, position = position_dodge(0.7)) +
    theme_classic() +
    facet_grid(.~Rlab, scales = "free_y", switch = "y") +
    scale_y_continuous(breaks = c(0,20,40,60,80,100,200,300,400,500)) +
    scale_color_manual(values = RColorBrewer::brewer.pal(9, "RdYlBu")[c(1,3,7,9)]) +
    theme(strip.background = element_blank(),
          strip.text = element_text(face = "bold", size = 14),
          strip.placement = "outside",
          panel.border = element_rect(color = "grey50", fill = NA, size = 0.5),
          axis.title = element_text(size = 11),
          axis.text = element_text(size = 10)) +
    labs(y = expression(bold(I[" sim"]^" tot")),
         shape = "Test Strategy &\nDelay")

ggsave(here::here("Plots/submit/Figure3.jpg"),
       units = "in", height = 5, width = 6.5, dpi = 600)

```

```{r rec_table, include = TRUE}
sims_sum_ggplot %>% 
  #filter(measure %in% c("Transmissions avoided/\n1000 tests", "Transmissions"), work_sched == "leaky") %>% 
  filter(measure == "Transmissions", work_sched == "leaky", delay %in% c(0,1), measure == "Transmissions", q75 <= thresh) %>% 
  group_by(R, `Community Prevalence`, delay) %>% 
  summarise(Thresh_freq = min(testfreq)) %>% 
  pivot_wider(names_from = R, values_from = Thresh_freq) %>% 
  arrange(delay) %>% 
  dplyr::select(-delay) %>% 
  knitr::kable()
# %>% 
#   kableExtra::group_rows(group_label = "Delay (d) = 0", 1,3) %>% 
#   kableExtra::group_rows(group_label = "Delay (d) = 1", 4,6) 

```

```{r sim_results_peravoided, include = FALSE, fig.width=7, fig.height=5, fig.cap="**Figure X. Percent of transmission events avoided due to different test strategies across transmission scenarios, test frequencies, and test delays**. Systematic testing strategies ([squares], [crosses]) prevent more infections than random strategies ([circles], [triangles]) across all transmission scenarios and test frequencies. More infections are expected in transmission scenarios with higher within facility $\\mathcal{R}$ and higher community prevalence. Preventing test delays (squares compared to crosses and triangles compared to circles) and increasing test frequency (red=lowest frequency, blue=highest frequency) also reduces the number of infections. The horizontal gray line serves as a reference to assess the testing frequency needed to maintain $\\mathcal{I}^{tot}_{sim}\\leq18$ (corresponding to one transmission event every ten days) across different transmission scenarios. Error bars represent the interquartile range of $\\mathcal{I}^{tot}_{sim}$ derived from 100 simulations per scenario."}
thresh  <-  days/10

sims_sum_ggplot %>% 
  #filter(measure %in% c("Transmissions avoided/\n1000 tests", "Transmissions"), work_sched == "leaky") %>% 
  filter(measure == "Pct Avoided", work_sched == "leaky", delay %in% c(0,1), `Test Frequency` != 0) %>% 
  mutate(`Test Frequency` = factor(case_when(`Test Frequency` == 0.5 ~ "0.5 (biweekly)",
                                             `Test Frequency` == 1 ~ "1 (weekly)",
                                             `Test Frequency` == 2 ~ "2 (twice weekly)",
                                             `Test Frequency` == 4 ~ "4 (every shift)"),
         levels = c("0.5 (biweekly)", "1 (weekly)", "2 (twice weekly)", "4 (every shift)"))) %>% #View()
  ggplot(aes(x = `Community Prevalence`,
             y = Med,
             ymin = q25,
             ymax = q75,
             shape = `Test Strategy Delay`,
             col = `Test Frequency`)) +
    geom_point(position = position_dodge(0.7)) +
    geom_errorbar(width = 0.1, position = position_dodge(0.7)) +
    theme_classic() +
    facet_grid(.~Rlab, scales = "free_y", switch = "y") +
    #scale_y_continuous(breaks = c(0,20,40,60,80,100,200,300,400,500)) +
    scale_color_manual(values = RColorBrewer::brewer.pal(9, "RdYlBu")[c(1,3,7,9)]) +
    theme(strip.background = element_blank(),
          strip.text = element_text(face = "bold", size = 14),
          strip.placement = "outside",
          panel.border = element_rect(color = "grey50", fill = NA, size = 0.5),
          axis.title = element_text(size = 11),
          axis.text = element_text(size = 10)) +
    labs(shape = "Test Strategy &\nDelay")

ggsave(here::here("Plots/Fig3_per_transmissions_avoided.png"),
       units = "in", height = 5, width = 7)
```

An alternative threshold approach to aid decision-making, particularly in resource-constrained settings, is the ITER. Figure 4 shows estimates of the ITER across transmission scenarios, test strategies, and test frequencies. In the highest transmission scenario ($\mathcal{R}=1.5$, $1\%$ community prevalence), testing systematically on the first day of every other work week with no delay ($f=0.5, d=0$, fig 4 squares) leads to $ITER=$ `r round(sims_sum_ggplot %>% filter(measure == "ITER", work_sched == "leaky", testsys == "systematic", delay ==0, testfreq == 0.5, commprev == 0.01, R == 1.5) %>% pull(Med), 2)` (IQR `r round(sims_sum_ggplot %>%  filter(measure == "ITER", work_sched == "leaky", testsys == "systematic", delay ==0, testfreq == 0.5, commprev == 0.01, R == 1.5) %>% pull(q25), 2)` - `r round(sims_sum_ggplot %>%  filter(measure == "ITER", work_sched == "leaky", testsys == "systematic", delay ==0, testfreq == 0.5, commprev == 0.01, R == 1.5) %>% pull(q75), 2)`), while increasing test frequency to weekly ($f=1$) results in $ITER=$ `r round(sims_sum_ggplot %>% filter(measure == "ITER", work_sched == "leaky", testsys == "systematic", delay ==0, testfreq == 1, commprev == 0.01, R == 1.5) %>% pull(Med), 2)` (IQR `r round(sims_sum_ggplot %>%  filter(measure == "ITER", work_sched == "leaky", testsys == "systematic", delay ==0, testfreq == 1, commprev == 0.01, R == 1.5) %>% pull(q25), 2)` - `r round(sims_sum_ggplot %>%  filter(measure == "ITER", work_sched == "leaky", testsys == "systematic", delay ==0, testfreq == 1, commprev == 0.01, R == 1.5) %>% pull(q75), 2)`), to twice weekly ($f=2$): $ITER=$ `r round(sims_sum_ggplot %>% filter(measure == "ITER", work_sched == "leaky", testsys == "systematic", delay ==0, testfreq == 2, commprev == 0.01, R == 1.5) %>% pull(Med), 2)` (IQR `r round(sims_sum_ggplot %>%  filter(measure == "ITER", work_sched == "leaky", testsys == "systematic", delay ==0, testfreq == 2, commprev == 0.01, R == 1.5) %>% pull(q25), 2)` - `r round(sims_sum_ggplot %>%  filter(measure == "ITER", work_sched == "leaky", testsys == "systematic", delay ==0, testfreq == 2, commprev == 0.01, R == 1.5) %>% pull(q75), 2)`), and to every shift ($f=4$): $ITER=$ `r round(sims_sum_ggplot %>% filter(measure == "ITER", work_sched == "leaky", testsys == "systematic", delay ==0, testfreq == 4, commprev == 0.01, R == 1.5) %>% pull(Med), 2)` (IQR `r round(sims_sum_ggplot %>%  filter(measure == "ITER", work_sched == "leaky", testsys == "systematic", delay ==0, testfreq == 4, commprev == 0.01, R == 1.5) %>% pull(q25), 2)` - `r round(sims_sum_ggplot %>%  filter(measure == "ITER", work_sched == "leaky", testsys == "systematic", delay ==0, testfreq == 4, commprev == 0.01, R == 1.5) %>% pull(q75), 2)`). These values approximately correspond to test positivity rates of `r paste0(round(100*1/sims_sum_ggplot %>% filter(measure == "ITER", work_sched == "leaky", testsys == "systematic", delay ==0, testfreq == 0.5, commprev == 0.01, R == 1.5) %>% pull(Med), 2), "%")`, `r paste0(round(100*1/sims_sum_ggplot %>% filter(measure == "ITER", work_sched == "leaky", testsys == "systematic", delay ==0, testfreq == 1, commprev == 0.01, R == 1.5) %>% pull(Med), 2), "%")`, `r paste0(round(100*1/sims_sum_ggplot %>% filter(measure == "ITER", work_sched == "leaky", testsys == "systematic", delay ==0, testfreq == 2, commprev == 0.01, R == 1.5) %>% pull(Med), 2), "%")`, and `r paste0(round(100*1/sims_sum_ggplot %>% filter(measure == "ITER", work_sched == "leaky", testsys == "systematic", delay ==0, testfreq == 4, commprev == 0.01, R == 1.5) %>% pull(Med), 2), "%")` due to the interpretation of the ITER as the number of tests per positive result. Figure 4 also provides an example reference line at $ITER=1000$, corresponding to an approximate $0.1\%$ test positivity, to demonstrate how testing frequency may be determined from the transmission scenario and target ITER, which may be influenced by the number of tests available.

```{r sim_results_iter, include = TRUE, fig.width=7, fig.height=4, fig.cap="**Figure 4. Incremental test effectiveness ratio (ITER) from simulations across transmission scenarios and testing frequencies and strategies**. The ITER remains relatively low in higher transmission scenarios even at high ($f=4$) testing frequencies, potentially favoring such high-frequency testing strategies when within-facility transmission ($\\mathcal{R}$) and/or community prevalence are high. The y-axis is log-transformed and the horizontal line at $ITER=1000$ is provided to aid visual comparison across scenarios. Error bars represent the interquartile range of expected infections derived from 100 simulations per scenario."}
sims_sum_ggplot %>% 
  mutate(`Test Frequency` = factor(case_when(`Test Frequency` == 0.5 ~ "0.5 (biweekly)",
                                             `Test Frequency` == 1 ~ "1 (weekly)",
                                             `Test Frequency` == 2 ~ "2 (twice weekly)",
                                             `Test Frequency` == 4 ~ "4 (every shift)"),
         levels = c("0.5 (biweekly)", "1 (weekly)", "2 (twice weekly)", "4 (every shift)"))) %>% 
  filter(measure == "ITER", work_sched == "leaky", delay %in% c(0,1), testfreq > 0) %>% 
  ggplot(aes(x = `Community Prevalence`,
             y = Med,
             ymin = q25,
             ymax = q75,
             col = `Test Frequency`,
             shape = `Test Strategy Delay`)) +
  geom_point(size = 1.2, position = position_dodge(1)) +
  geom_errorbar(width = 0.1, position = position_dodge(1)) +
  geom_hline(yintercept = 1000, col = "grey50", alpha = 0.5) +
  facet_grid(.~Rlab, scales = "free_y", switch = "y") +
  scale_y_continuous(trans = "log", 
                     breaks = c(250, 1000, 2500, 10000, 25000)) +
  scale_color_manual(values = RColorBrewer::brewer.pal(9, "PuOr")[c(1,3,7,9)]) +
  theme_classic() +
  theme(axis.title = element_text(size = 12),
        axis.text = element_text(size = 10),
        strip.text = element_text(face = "bold", size = 14),
        strip.background = element_blank()) +
  labs(y = "ITER",
       shape = "Test Strategy &\nDelay")

ggsave(here::here("Plots/Fig4_ITER.png"),
       units = "in", height = 4, width = 7)

ggsave(here::here("Plots/submit/Figure4.jpg"),
       units = "in", height = 4, width = 6.5, dpi = 600)

```

